<!DOCTYPE = html>
<html lang="cn">

<h1>题目描述</h1>

<p>Tom最近在研究一个有趣的排序问题。如图所示，通过2个栈S1和S2，Tom希望借助以下4种操作实现将输入序列升序排序。 - 操作a: 如果输入序列不为空，将第一个元素压入栈S1 - 操作b: 如果栈S1不为空，将S1栈顶元素弹出至输出序列 - 操作c: 如果输入序列不为空，将第一个元素压入栈S2 - 操作d : 如果栈S2不为空，将S2栈顶元素弹出至输出序列</p>

<p>如果一个1~n的排列P可以通过一系列操作使得输出序列为1, 2,…,(n-1), n，Tom就称P是一个"可双栈排序排列"。例如(1, 3, 2, 4)就是一个"可双栈排序序列"，而(2, 3, 4, 1)不是。下图描述了一个将(1, 3, 2, 4)排序的操作序列：<code>&lt;a, c, c, b, a, d, d, b&gt;</code></p>

<p>当然，这样的操作序列有可能有几个，对于上例(1, 3, 2, 4)，&lt;a, c, c, b, a, d, d, b>是另外一个可行的操作序列。Tom希望知道其中字典序最小的操作序列是什么。</p>

<h2>输入格式</h2>

<p>输入有多个样例，以EOF结束。 输入的第一行是一个整数n。第二行有n个用空格隔开的正整数，构成一个1~n的排列。
</p>

<h2>输出格式</h2>

<p>输出共一行，如果输入的排列不是"可双栈排序排列"，输出数字0；否则输出字典序最小的操作序列，每两个操作之间用空格隔开，行尾没有空格。</p>

<h2>输入样例</h2>

<p>3 2 3 1 4 1 3 2 4 4 2 3 4 1</p>

<h2>输出样例</h2>

<p>a c a b b d a b a a b b a b 0
</p>

<h1>分析</h1>

<p>题目分为两个部分：判断是否有解和找出最小字典序列</p>

<h2>判断是否有解</h2>

<h3>引理</h3>

<p>考虑对于任意两个数q1[i]和q1[j]来说,它们不能压入同一个栈中的充要条件是：(注意没有必要使它们同时存在于同一个栈中,只是压入了同一个栈)存在一个k,使得<code>i &lt; j &lt; k</code> 且 <code>q1[k] &lt; q1[i] &lt; q1[j]</code> 证明略
</p>

<h3>判断过程</h3>

<p>我们的目标是要判断一个序列是否是“能双栈排序”序列，如果直接利用引理来遍历整个序列，那么我们需要<code>O(n^3)</code>的时间。但是在枚举的过程中，我们发现可以先判断<code>q1[i] &lt; q1[j]</code>是否满足，其次再判断所有<code>k &gt; j</code>是否满足<code>q1[k] &lt; q1[i]</code>。也就是说，我们可以先得到一个<strong>序号大于i但值小于q[i]的最小值</strong>序列，再用这个序列来判断引理是否成立，那么复杂度会大大降低。</p>

<blockquote>
    <p>设F[i]为Min{S[i],S[i+1],S[i+2]..S[n-1],S[n]},状态转移方程为F[i]=Min{S[i] , F[i+1]}.边界为F[N+1]=极大的值。</p>
</blockquote>

<p>找到F后，我们再思考<strong>能否放入同一个栈</strong>这个性质。我们很（bu）自然的就想到了二分图——如果不能进入同一个栈则连上一条边，最后我们就把这个问题转化成了图色问题。 建立临接表过程比较简单，就是只要满足引理条件就连上。 图色的过程如果熟悉图论也比较简单，可是我们并不熟悉，所以还是说一下。我们从第0个数开始图色，图了第0个之后再图和他有关系的点（即不能进入同一个栈的数）。找完了所有有关系的数那么就图下一个。
</p>

<blockquote>
    <p>如果在图色的过程中出现冲突，则图色失败，表示不符合条件。</p>
</blockquote>

<h2>找出字典序最小的组合</h2>

<blockquote>
    <p>因为a、b都是在第一个栈操作，所以我们尽量都先进入第一个栈，即默认先图颜色一。</p>
</blockquote>

<p>然后就找到了最小的组合？！！</p>

<h2>输出</h2>

<p>输出的时候我们只需要按照已经图好的颜色，按照序列顺序压栈即可。 弹出的过程不要想的太复杂，实际上只是按照最后的结果1234弹出就行了。我们设置一个变量count = 1，如果发现两个栈中任意一个的顶端元素是等于count，那么就把这个数弹出，并且自增count 因为要输出成一些比较漂亮的样子，所以再考虑下空格就好了。
</p>

<h1>源码</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;stack&gt;
#include &lt;algorithm&gt;
using namespace std;

const int MAX = 1001;
const int INF = 99999999;

int S[MAX], F[MAX], bel[MAX];
bool adj[MAX][MAX];
int T;
int flag = 1;

void init() {
  for (int i = 0; i &lt; T; i++) {
    scanf("%d", &amp;S[i]);
  }
}

void noanswer() {
  cout &lt;&lt; "0";
  flag = 0;
}

void color(int i, int c) {
  if (flag == 0) return;
  bel[i] = c;
  for (int j = 0; j &lt; T; j++) {
    if (adj[i][j]) {
      if (bel[j] == c) {
        noanswer();  // conflict
        return;
      }
      if (flag == 0) return;
      if (!bel[j]) {
        color(j, 3 - c);  // color the opposite color 1&lt;-&gt;2
        if (flag == 0) return;
      }
    }
  }
}

void addedge() {
  F[T] = INF;
  for (int i = T - 1; i &gt;= 0; i--) {
    F[i] = min(F[i + 1], S[i]);
  }
  for (int i = 0; i &lt; T - 1; i++) {
    for (int j = i + 1; j &lt; T; j++) {
      if (S[i] &lt; S[j] &amp;&amp; F[j + 1] &lt; S[i]) {
        adj[i][j] = adj[j][i] = true;
      }
    }
  }
  for (int i = 0; i &lt; T; i++) {
    if (!bel[i]) {
      color(i, 1);
    }
  }
}

void solve() {
  if (flag == 0) return;
  int s, should = 1;
  stack&lt;int&gt; s1, s2;
  for (int i = 0; i &lt; T; i++) {
    s = bel[i];
    if (s == 1) {
      s1.push(S[i]);
      cout &lt;&lt; "a ";
    } else {
      s2.push(S[i]);
      cout &lt;&lt; "c ";
    }

    while ((!s1.empty() &amp;&amp; s1.top() == should) ||
           (!s2.empty() &amp;&amp; s2.top() == should)) {
      if (s1.top() == should) {
        s1.pop();
        cout &lt;&lt; "b";
        if (should != T) cout &lt;&lt; " ";
        should++;
      } else {
        s2.pop();
        cout &lt;&lt; "d";
        if (should != T) cout &lt;&lt; " ";
        should++;
      }
    }
  }
}

int main() {
  while (cin &gt;&gt; T) {
    init();
    addedge();
    solve();
    cout &lt;&lt; endl;
    for (int i = 0; i &lt; T; i++) {
      S[i] = F[i] = bel[i] = 0;
      for (int j = 0; j &lt; T; j++) {
        adj[i][j] = false;
      }
    }
    flag = 1;
  }
  return 0;
}
</code></pre>

</html>