最近在学习 [动态规划](https://en.wikipedia.org/wiki/Dynamic_programming), 不得不说这是一个有（hen）趣（nan）的算法。学习之后也发现自己还几乎不能正确的使用它（尴尬）。但是又感觉学了很多东西，所以在这里记录一下。  
其实这个算法并不陌生，我们在 [Fibonacci序列](https://en.wikipedia.org/wiki/Fibonacci_number) 以及 [背包问题]() 中就曾有过接触。这里先以 Fibonacci序列 作为一个切入口。我们在计算FS的时候，主要有两种方法：递归法和循环法（其实是一样的）。用到递归的原因是：大问题可以简化成一些 **类似的子问题的集合** 。可以这么说，每一个问题的解出都需要有其他问题的推动。  

# 记忆型递归

如果你只是写了一个递归算法没有任何的优化的话，你的算法肯定会 **非常慢**，因为它的时间复杂度是指数级别的。而通常DP问题直接递归是会超时的。可是我们仔细思考一下，在计算的过程中我们会遇到很多重复计算的情况。比如说算F(5)的时候，你先算F(4)，再算F(3)，可是在算F(4)的时候已经算过F(3)了。这里就会造成很大的浪费。所以我们简单的优化一下，把之前计算过的数字存起来，下次算的时候如果算过就不再算了。
```cpp
int F[100];
int Fibonacci(int num) {
  if (F[num] == 0) {
    if (num == 0 || num == 1) F[num] = 1
    else F[num] =  Fibonacci(num-1) + Fibonacci(num-2);
  }
  return F[num];
}
```
这个就是记忆递归类型。这种类型的特点就是：代码好写！（因为递归很贴近人类而反电脑hhh），并且如果要用记忆递归的话，子问题之间是要有 **嵌套** 的关系的。可是这种问题在生活中并不常见（黑脸）。所以我们要需要接下来的方法。

# “人人为我”型递推
不是说递归回超时吗？我们就用递推好了。可是递推相比之下会难想很多，因为要考虑一个递推公式。在思考递推公式当中，*人人为我* 是一种比较好想的方式。我们依然拿FS为例子。
```
int F[100];  // 预先设置F[0]和F[1]为1
void Fibonacci(int num) {
  for (int i = 1; i < num; i++) {
    F[i+1] = F[i] + F[i-1];
  }
  cout << F[num] << endl;
}
```
“人认为我”的意思也就是说我们要求的最终目标是“我”，站立在一个数组的顶端。而其他数组底部的人都是为了算出“我”。这里用到的递推公式就是 `F[i+1] = F[i] + F[i-1]`，省去递归之烦。

# 几个例题
## [POJ-1163 Triangle](http://poj.org/problem?id=1163)
这道题我们要求的是从顶点向下的一条和最大的路径。这里用贪心是肯定不行的，因为每一步的最佳选择并不一定会导致最终结果最优。也许某一条路径第一个数字很小，但是后面的数字很大，但是第一次就被直接pass掉了。所以很不幸，这里必须要把所有的路径都遍历一次才能找到最大的一条路径。  
因为顶点开始的最大路径是由 **下一排所有最大路径中最大值** 决定的。也就是说在下图中，7向下的和最大的路径=max(3向下最大路径，8向下最大路径) + 7。这道题的递推公式很简单就能够得到了： `maxSum[i][j] = max(maxSum[i+1][k])` k = 0...j。
```
      7
    3   8
  8   1   0
2   7   4   4
```
[Source Code](https://github.com/ECer23/C-Study/blob/master/ACM/dynamic_planning/Triangel.cpp)


## [POJ-1458 Longest Common Sequence](http://poj.org/problem?id=1458)
这道题要找的是最长公共子序列的长度（注意：这里公共子序列不一定要连续。比如abcsb和awbcb最长公共子序列是abcb）。很显然公共子序列也是一个由很多子问题嵌套的大问题，我们可以把一个abcsb和awbcb的公共子序列问题分解成 **abcs和awbc的公共子序列 + 判断最后一个一不一样** 之后再使用递归递推就都可以了。
[Source Code](https://github.com/ECer23/C-Study/blob/master/ACM/dynamic_planning/LCS.cpp)

## [POJ-1088 滑雪](http://poj.org/problem?id=1088)
这道题要找的是最长的滑雪路径，其实和第一道题很类似。我们要找的子问题是一个点周围的点的最长滑雪路径加上自己就OK。但是这道题难的地方在你不能找到一个先后顺序。第一题中有很明显的先后顺序，我们从第一排到最后一排。而这道题没有先后顺序。所以我们的解决办法是先对他们进行排序，排序之后再从低到高计算最长滑雪路径，输出最后一个值。
[Source Code](https://github.com/ECer23/C-Study/blob/master/ACM/dynamic_planning/skii.cpp)